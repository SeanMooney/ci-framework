#!/usr/bin/env bash
# Copyright Red Hat, Inc.
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

##----------------------------------------------------------------------------
## Shell Opts ----------------------------------------------------------------
##----------------------------------------------------------------------------
set -o pipefail

##----------------------------------------------------------------------------
# Define the ANSI color codes ------------------------------------------------
##----------------------------------------------------------------------------
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

##----------------------------------------------------------------------------
## Functions -----------------------------------------------------------------
##----------------------------------------------------------------------------

# this function works in case of long running command  with verbous mode
progress_indicator() {
    local aux_file=$1 # warning: file content is mutable
    local command=$2  # long running command

    touch "$aux_file"         # create the auxiliary file if it doesn't exist
    truncate -s 0 "$aux_file" # delete content (if existing)

    previous_size=$(stat -c %s "$aux_file")

    # run the long running command in the background
    eval $command &>"$aux_file" &
    background_pid=$!

    while kill -0 "$background_pid" >/dev/null 2>&1; do
        current_size=$(stat -c %s "$aux_file")
        if [[ $current_size -gt $previous_size ]]; then
            echo -n "#"                 # print "#" if the file size has increased
            previous_size=$current_size # update previous size
        fi
        sleep 1 # wait for 1 second before checking again
    done
}

# long_running_command=(find / -exec ls -ld '{}' \; -exec sleep 1 \;)
# long_running_command="${long_running_command[@]}"
# progress_indicator "$aux_file" "$long_running_command"

# this function builds an a step based interactive option menu
# returns:
#    1 to indicate that Quit option was selected
#    0 otherwize
interactive_cmd_assembly() {
    local options_list=$1
    local step=$2

    # Split the into an array of options
    IFS=$'\n' read -rd '' -a options <<<"$options_list"

    # Add the "Quit" option
    options+=("Quit")

    # Create the interactive menu
    PS3="Select "$step": "
    select opt in "${options[@]}"; do
        case $opt in
        "Quit")
            return 1
            ;;
        *)
            echo "You selected: $opt"

            # choose flavor
            if [[ $step == "flavor" ]]; then
                read -r flavor _ <<<"$opt"
                echo "Result: "$flavor
            fi

            # choose Centos image
            if [[ $step == "image" ]]; then
                read -r image _ <<<"$opt"
                echo "Result: "$image
            fi

            return 0
            ;;
        esac
    done
}

check_ssh_reachable() {
    local ssh_port=22
    nc -z -w 2 $instance_ip $ssh_port
    return $?
}

wait_for_sshd() {
    # Set the maximum number of retries
    local max_retries=30

    # Set the delay between retries (in seconds)
    local retry_delay=5

    # Loop to check SSH reachability
    retry_count=0
    while ! check_ssh_reachable; do
        retry_count=$((retry_count + 1))
        if [ $retry_count -gt $max_retries ]; then
            echo "${RED}SSH is not reachable after $max_retries retries${NC}"
            exit 1
        fi
        echo "SSH is not reachable. Retrying in $retry_delay seconds..."
        sleep $retry_delay
    done

}

##----------------------------------------------------------------------------
## entry point----------------------------------------------------------------
##----------------------------------------------------------------------------

# Enable autocompletioni and readline functionality only
# when the script is executed in an interactive shell
if [[ $- == *i* ]]; then
    bind "set completion-ignore-case on"
    bind "TAB: menu-complete"
fi

# Check if the path argument is provided
if [ -z "$1" ]; then
    echo "Please provide a path to your openrc file."
    read -e -p "Enter a path: " -i "~/" path
else
    path="$1"
fi

# Expand the path, including the tilde (~) character
eval "expanded_path=$path"

# source OS_ env variables from the openrc file
source $expanded_path

# Recommended requirements
cpu_cores=12
ram_capacity=32768 #MiB
disk_capacity=100  #GiB

##----------------------------------------------------------------------------
# Capture flavors as an output of the command addressing recommended
# requirements and build a menu
echo -e "${BLUE}Selecting an instance flavor${NC}"
flavors=$(openstack flavor list -c Name -c RAM -c Disk -c VCPUs -f value |
    awk -v cpu_cores=$cpu_cores \
        -v ram_capacity="$ram_capacity" \
        -v disk_capacity=$disk_capacity \
        '$2>ram_capacity && $3>disk_capacity && $4>cpu_cores')
output=$(interactive_cmd_assembly "$flavors" "flavor")
if [ $? == 1 ]; then
    echo "Exiting..."
    exit 0
fi
flavor_name=$(echo "$output" | grep "Result:" | awk '{print $2}')

##----------------------------------------------------------------------------
# Capture Centos images as an output of the command and build a menu
echo -e "${BLUE}Selecting an instance image${NC}"
aux_file="/tmp/auxilary.txt"
long_running_command="openstack image list -vvv"
progress_indicator "$aux_file" "$long_running_command"

echo "" # jump to the next line
pattern="ID[[:space:]]*|[[:space:]]*Name[[:space:]]*|[[:space:]]*Status"
output=$(sed -n "/$pattern/,\$p" "$aux_file" | grep -i centos | awk '{ print $4; }')
images=$(echo "$output" | tail -n +1) #  everything after the pattern
output=$(interactive_cmd_assembly "$images" "image")
image_name=$(echo "$output" | grep "Result:" | awk '{print $2}')

##----------------------------------------------------------------------------
# Select less congested network
echo -e "${BLUE}Choosing the less congested network${NC}"
long_running_command="openstack network list --external -c Name -f value | \
                        xargs -r -n1 openstack ip availability show -f json"
progress_indicator "$aux_file" "$long_running_command"
echo "" # jump to the next line
network_name=$(cat $aux_file |
    jq -r '.id as $network_id | .subnet_ip_availability[] | select(.ip_version == 4) | "\(.total_ips - .used_ips) \($network_id)"' |
    sort -nr | head -n1 | awk ' {{print  $NF}}' | xargs -n1 openstack network show -c name -f value)

##----------------------------------------------------------------------------
# Importing publik key to the cloud
echo -e "${BLUE}Handling key pair import${NC}"
pubkey_path=~/.ssh/id_rsa.pub
keypair_name="$(whoami)"-edpm-key

# Check if the public key file exists
if [[ ! -f $pubkey_path ]]; then
    echo "Error: Public key file not found at $pubkey_path"
    echo "Please generate one and start over."
    exit 1
fi

# Check if the key pair name already exists
existing_keypair=$(openstack keypair show -f value -c name $keypair_name 2>/dev/null)
if [[ -n $existing_keypair ]]; then
    echo -e "${RED}Warning: Key pair with the name $keypair_name already exists${NC}"
else
    # Import the key pair
    openstack keypair create --public-key $pubkey_path $keypair_name
fi

##----------------------------------------------------------------------------
# Create a vm with values selected peviously
instanse_name="e2e-edpm-deployment"
echo -e "${BLUE}Creating $instanse_name instance${NC}"
output=$(openstack server create --flavor $flavor_name --image $image_name \
    --key-name $keypair_name --network $network_name \
    --security-group default $instanse_name)
if [ $? -ne 0 ]; then
    echo -e "${RED}Error: Failed to create an instance${NC}"
    exit 1
fi
instance_id=$(echo "$output" | awk '/ id / {print $4}')

##----------------------------------------------------------------------------
# Wait until instance is ACTIVE and print log-in command
start_time=$(date +%s)

echo -e "${BLUE}Waiting for instance to become ACTIVE${NC}"

# Loop until the instance status becomes ACTIVE or timeout occurs
while :; do
    # Get the current status
    status=$(openstack server show $instance_id -f value -c status)

    if [[ $status == "ACTIVE" ]]; then
        # Instance is active, get the IP address and print it
        instance_ip=$(openstack server show $instance_id -f json -c addresses |
            jq -r --arg netname "$network_name" '.addresses | to_entries[] | select(.key == $netname) | .value[0]')
        echo "" # jump to the next line
        break
    fi

    # Check if more than 2 minutes have passed
    current_time=$(date +%s)
    elapsed_time=$((current_time - start_time))

    if ((elapsed_time > 120)); then
        echo "Error: Timeout occurred while waiting for instance to become ACTIVE."
        exit 1
    fi

    echo -n "#" # progress indicator
    sleep 1
done

##----------------------------------------------------------------------------
# Commands to execute on the instance
echo -e "${BLUE}Istalling packages required for ci-framework${NC}"

# "ACTIVE" status does not necessarily indicate that sshd is running
wait_for_sshd

ssh_cmd="ssh -v -o StrictHostKeyChecking=no -t cloud-user@$instance_ip -i $pubkey_path"

commands=(
    "${ssh_cmd} eval 'sudo dnf -y groupinstall \"Development Tools\"'"
    "${ssh_cmd} eval 'sudo dnf -y install qemu-img qemu-kvm libguestfs libguestfs-tools-c wget pip'"
    "${ssh_cmd} eval 'python3 -m pip install --user ansible jmespath beautifulsoup4'"
)

# Iterate over the commands and execute the progress_indicator function
installed_all_packages=true
for cmd in "${commands[@]}"; do
    $cmd # or use "progress_indicator "aux_file" "$cmd"" to hide the output

    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Failed to perform $cmd${NC}"
        installed_all_packages=false
    fi
done

##----------------------------------------------------------------------------
# How to connect to the instance
if [[ $installed_all_packages == true ]]; then
    echo -e "${BLUE}Congrats! The instance is ready:${NC}"
else
    echo -e "${RED}Install packages manulally:${NC}"
fi
echo "  ssh cloud-user@$instance_ip -i $pubkey_path"
